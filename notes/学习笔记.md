## ES2015
###  1. 块级作用域
>  let 块级作用域，花括号{}之外的作用域是无法访问到let声明的变量的

>  var 是在全局作用域或者函数作用域当中， 并且var声明的变量会提升到作用域的最前面，即可以先使用变量再声明变量

>  const 在声明时就必须给变量赋值否则就会报错，一旦赋值之后变量就不允许重新赋值，作用域同let

### 2. 数组解构
``` 
let arr = [11,22,33]

let [a,b,c] = arr

```
> 可以将对应的数值复制到数组对应位置的变量当中

```
let [a,...res] = arr
```
> `...`运算符必须在数组结构的最后的位置，用来存储剩余位置的数组所有的值

```
let [a,b,c,d='default value'] = arr
```
> 可以给数组结构的变量设置默认值，当结构的数组变量的值为undefined时，就会使用数组结构对象的默认值

### 3. 对象解构
```
const obj = {name:'zce', age:18}
const {name, age} = obj
```
> 可以将对象中指定属性名的变量解构出来

```
const name = 'zce'
const {name: objname = 'jack'} = obj
```
> 如果解构的变量名有冲突，可以对解构的变量名进行重命名，并且也可以给解构的变量设置默认值

### 4. 模板字符串
```
const name = 'zce'
const str = `name is ${name}---${1 + 1}----${Math.random()} \`name\``
```
> 可以使用反引号来定义模板字符串，并且可以使用${}的形式插入任意的javascript的表达式，如果模板字符串中需要显示反引号，则可以用反斜杠来转译字符

```
const name = 'zce'
const gender = 'man'

function myTagFunc(strings, name, gender) {
  return strings[0] + name + strings[1] + gender + strings[2]
}

const result = myTagFunc`hey, ${name} is a ${gender}.`
```
> 带标签的模板字符串，首先标签就是一个函数，该函数的第一个参数就是以${}分隔开的字符串数组，后面的的参数就是对应的${}中的表达式的结果

### 5. 字符串的扩展方法
```
const message = 'Error: foo is not defined'
message.startsWith('Error') // true
message.endsWith('.') // true
message.includes('foo') // true
```
> `startsWith(xx)`字符串是否以xx开始

> `endsWith(xx)`字符串是否以xx结尾

> `includes(xx)`字符串中是否包含xx

### 6. 参数的默认值
```
funcion foo(enable = true) {
  console.log(enable)
}

foo() // true
```
> 参数的默认值，当传入的参数为undefined时就会使用参数的默认值，带默认值的函数参数最好在参数列表的末尾， 因为参数是按照顺序传递的，如果默认值不在末尾，参数的默认值将无法正常工作

### 7. 剩余参数
```
function foo(...args) {
  console.log(args)
}
foo(1,2,3,4)
```
> 剩余参数用ES6的...的形式声明，并且剩余参数只能出现在形参列表的最后面，代表所有的剩余参数的集合，用来代替之前的arguments对象。

### 8. 展开数组
```
const arr = [1,2,3]
console.log(...arr)
```
> 使用...展开运算符，将arr数组中的所有元素展开到log方法中作为参数

### 9. 箭头函数
```
const inc = n => n + 1
console.log(inc(100))
```

### 10. 箭头函数与this
```
const obj = {
  name: 'tom',
  say:() => console.log(`my name is ${this.tom}`),
  sayHi() { console.log(`my name is ${this.tom}`) }
}

console.log(obj.say()) // tom is undefined
console.log(obj.sayHi()) // my name is tom
```
> 箭头函数不会改变this的指向,this始终指向当前环境的this对象

### 11. 对象字面量增强
```
const bar = '123'

const obj = {
  bar, // 省略 ‘:bar’
  foo: '123',
  [Math.random()]: '123', // 计算属性名
  method() {} // 省略 ‘:function’
}
```

### 12. 对象方法的扩展
```
Object.assign(target,source1,source2,...)
```
> 将多个源对象的属性复制到一个目标对象当中

```
+0 === -0 // true
Object.is(+0,-0) // false
NAN === NAN // false
Object.is(NAN, NAN) // true
```
> 新的比较两个值是否相等的方法

### 13. Proxy 代理对象
```
const person = {
  name: 'zce',
  age: 20
}

new personProxy = new Proxy(person, {
  get(target, property) {
    return property in target ? target[property] : 'default'
  },
  set(target, property, value) {
    if(property === 'age') {
      if(!Number.isInteger(value)) {
        throw new TypeError(`${value} is not an int`)
      }
    }
    target[property] = value
  }
})

personProxy.age = '20' // TypeError '20' is not an int

console.log(personProxy.name)  // zce
console.log(personProxy.xxx)  // default
```

### 14. Proxy vs Object.defineProperty
```
const persion = {
  name: 'zce',
  age: 20
}

const personProxy = new Proxy(person, {
  deleteProperty(target, property) {
    console.log('delete', property)
    delete target[property]
  }
})

delete personProxy.age // delete age

const list = []

const listProxy = new Proxy(list, {
  set(target, property, value) {
    console.log('set', property, value)
    target[property] = value
    return true
  }
})

listProxy.push(100) // set 0 100
```
> defineProperty 只能监听到对象的读取和赋值操作，Proxy以非侵入的方式监听了整个对象的读写，并且可以监听到删除、数组的读写等等。

### 15. Reflect
```
const obj = {
  name: 'zce',
  age: 20
}
Reflect.has(obj, 'name') // 'name' in obj
Reflect.deleteProperty(obj, 'age') // delete obj.age
Reflect.ownKeys(obj) // Object.keys(obj)
```
> Reflect 内部封装了一系列对对象的底层操作，Reflect成员方法就是Proxy处理对象的默认实现,提供了一套用于操作对象的API


### 16. Promise
> ES6提供的一种解决异步操作回调过深的问题的操作。

### 17. class 类
```
// ES5
function Person(name) {
  this.name = name
}

Person.protoType.say = function() {
  console.log(`my name is ${this.name}`)
}

// ES6
class Person {
  constructor(name) {
    this.name = name
  }

  say() {
    console.log(`my name is ${this.name}`)
  }
}
```
> ES6提供了新的类的定义方式

### 18. 静态方法

