## ES2015
###  1. 块级作用域
>  let 块级作用域，花括号{}之外的作用域是无法访问到let声明的变量的

>  var 是在全局作用域或者函数作用域当中， 并且var声明的变量会提升到作用域的最前面，即可以先使用变量再声明变量

>  const 在声明时就必须给变量赋值否则就会报错，一旦赋值之后变量就不允许重新赋值，作用域同let

### 2. 数组解构
``` 
let arr = [11,22,33]

let [a,b,c] = arr

```
> 可以将对应的数值复制到数组对应位置的变量当中

```
let [a,...res] = arr
```
> `...`运算符必须在数组结构的最后的位置，用来存储剩余位置的数组所有的值

```
let [a,b,c,d='default value'] = arr
```
> 可以给数组结构的变量设置默认值，当结构的数组变量的值为undefined时，就会使用数组结构对象的默认值

### 3. 对象解构
```
const obj = {name:'zce', age:18}
const {name, age} = obj
```
> 可以将对象中指定属性名的变量解构出来

```
const name = 'zce'
const {name: objname = 'jack'} = obj
```
> 如果解构的变量名有冲突，可以对解构的变量名进行重命名，并且也可以给解构的变量设置默认值

### 4. 模板字符串
```
const name = 'zce'
const str = `name is ${name}---${1 + 1}----${Math.random()} \`name\``
```
> 可以使用反引号来定义模板字符串，并且可以使用${}的形式插入任意的javascript的表达式，如果模板字符串中需要显示反引号，则可以用反斜杠来转译字符

```
const name = 'zce'
const gender = 'man'

function myTagFunc(strings, name, gender) {
  return strings[0] + name + strings[1] + gender + strings[2]
}

const result = myTagFunc`hey, ${name} is a ${gender}.`
```
> 带标签的模板字符串，首先标签就是一个函数，该函数的第一个参数就是以${}分隔开的字符串数组，后面的的参数就是对应的${}中的表达式的结果

### 5. 字符串的扩展方法
```
const message = 'Error: foo is not defined'
message.startsWith('Error') // true
message.endsWith('.') // true
message.includes('foo') // true
```
> `startsWith(xx)`字符串是否以xx开始

> `endsWith(xx)`字符串是否以xx结尾

> `includes(xx)`字符串中是否包含xx

### 6. 参数的默认值
```
funcion foo(enable = true) {
  console.log(enable)
}

foo() // true
```
> 参数的默认值，当传入的参数为undefined时就会使用参数的默认值，带默认值的函数参数最好在参数列表的末尾， 因为参数是按照顺序传递的，如果默认值不在末尾，参数的默认值将无法正常工作

### 7. 剩余参数
```
function foo(...args) {
  console.log(args)
}
foo(1,2,3,4)
```
> 剩余参数用ES6的...的形式声明，并且剩余参数只能出现在形参列表的最后面，代表所有的剩余参数的集合，用来代替之前的arguments对象。

### 8. 展开数组
```
const arr = [1,2,3]
console.log(...arr)
```
> 使用...展开运算符，将arr数组中的所有元素展开到log方法中作为参数

### 9. 箭头函数
```
const inc = n => n + 1
console.log(inc(100))
```

### 10. 箭头函数与this
```
const obj = {
  name: 'tom',
  say:() => console.log(`my name is ${this.tom}`),
  sayHi() { console.log(`my name is ${this.tom}`) }
}

console.log(obj.say()) // tom is undefined
console.log(obj.sayHi()) // my name is tom
```
> 箭头函数不会改变this的指向,this始终指向当前环境的this对象

### 11. 对象字面量增强
```
const bar = '123'

const obj = {
  bar, // 省略 ‘:bar’
  foo: '123',
  [Math.random()]: '123', // 计算属性名
  method() {} // 省略 ‘:function’
}
```

### 12. 对象方法的扩展
```
Object.assign(target,source1,source2,...)
```
> 将多个源对象的属性复制到一个目标对象当中

```
+0 === -0 // true
Object.is(+0,-0) // false
NAN === NAN // false
Object.is(NAN, NAN) // true
```
> 新的比较两个值是否相等的方法

### 13. Proxy 代理对象
```
const person = {
  name: 'zce',
  age: 20
}

new personProxy = new Proxy(person, {
  get(target, property) {
    return property in target ? target[property] : 'default'
  },
  set(target, property, value) {
    if(property === 'age') {
      if(!Number.isInteger(value)) {
        throw new TypeError(`${value} is not an int`)
      }
    }
    target[property] = value
  }
})

personProxy.age = '20' // TypeError '20' is not an int

console.log(personProxy.name)  // zce
console.log(personProxy.xxx)  // default
```

### 14. Proxy vs Object.defineProperty
```
const persion = {
  name: 'zce',
  age: 20
}

const personProxy = new Proxy(person, {
  deleteProperty(target, property) {
    console.log('delete', property)
    delete target[property]
  }
})

delete personProxy.age // delete age

const list = []

const listProxy = new Proxy(list, {
  set(target, property, value) {
    console.log('set', property, value)
    target[property] = value
    return true
  }
})

listProxy.push(100) // set 0 100
```
> defineProperty 只能监听到对象的读取和赋值操作，Proxy以非侵入的方式监听了整个对象的读写，并且可以监听到删除、数组的读写等等。

### 15. Reflect
```
const obj = {
  name: 'zce',
  age: 20
}
Reflect.has(obj, 'name') // 'name' in obj
Reflect.deleteProperty(obj, 'age') // delete obj.age
Reflect.ownKeys(obj) // Object.keys(obj)
```
> Reflect 内部封装了一系列对对象的底层操作，Reflect成员方法就是Proxy处理对象的默认实现,提供了一套用于操作对象的API


### 16. Promise
> ES6提供的一种解决异步操作回调过深的问题的操作。

### 17. class 类
```
// ES5
function Person(name) {
  this.name = name
}

Person.protoType.say = function() {
  console.log(`my name is ${this.name}`)
}

// ES6
class Person {
  constructor(name) {
    this.name = name
  }

  say() {
    console.log(`my name is ${this.name}`)
  }
}
```
> ES6提供了新的类的定义方式

### 18. 静态方法
```
class Person {
  constructor(name) {
    this.name = name
  }

  say() {
    console.log(`my name is ${name}`)
  }

  static create(name) {
    return new Person(name)
  }
}

const person = Person.create('tom')
person.say()
```
> 静态方法的this指向类型本身，实例方法的this指向类的实例

### 19. 类的继承
```
class Person {
  constructor(name) {
    this.name = name
  }

  say() {
    console.log(`hi, my name is ${this.name}`)
  }
}

class Student extends Person {
  constructor(name, number) {
    super(name)
    this.number = number
  }

  hello() {
    super.say()
    console.log(`my school number is ${this.number}`)
  }
}

const s = new Student('jack', '100')
s.hello() // hi, my name is jack 
          // my school number is 100
```
> 使用extends关键字来实现继承 super指向父类的构造函数

### 20. Set 数据结构
```
const s = new Set()
s.add(1).add(2).add(3).add(4) // 添加元素 add方法返回集合本身
s.size // 集合的长度
s.has(1) // 集合中是否有该元素 返回 true or false
s.clear() // 清除集合中的所有元素
s.forEach(i => console.log(i)) // 遍历集合

const arr = [1,2,3,1,4]
const result = Array.from(new Set(arr)) // 数组去重
console.log(result) // [1,2,3,4]
```
> set的成员不允许重复

### 21. Map 数据结构
```
const m = new Map()
const tom = {name: 'tom'}
m.set(tom, 90)
console.log(m.get(tom)) // 90 

m.has(tom) // 是否存在 true or false
m.delete(tom) // 删除
m.clear() // 清除map
m.forEach((value, key) => console.log(key, value)) // {name: 'tom'} 90 遍历
```
> map的键可以是任意类型

### 22. Symbol 类型
```
Symbol() === Symbol() // false

const name = Symbol()
const obj = {
  [name]: 'zce',
  say() {
    console.log(this[name])
  }
}
console.log(obj.say()) // zce 只能通过对象的方法来访问的对象成员 用Symbol实现对象的私有成员
```
> 最主要的作用就是为对象添加独一无二的属性名

```
Symbol.for('foo') === Symbol.for('foo') // true 
```
>  相同的字符串就会返回相同的symbol值 参数只能接受字符串，如果不是字符串便会转换为字符串然后再生成symbol值
```
Symbol.iterator
Symbol.hasInstance
Symbol.toStringTag

const obj = {
  [Symbol.toStringTag]: XObject',
  foo: 'normal value'
}

console.log(obj.toString()) // [object XObject]
```
> 可以使用Symbol的toString常量来改变toString方法的计算结果
> 可以通过Object.getOwnPropertySymbols，来获取对象的所有symbol类型的属性

### 23. for..of循环
> ES6提出的一种数据统一遍历方式，只要一种数据结构实现了Iterator接口，它就能够被for...of循环来遍历

### 24. 迭代器接口
```
const s = new Set([1,2,3])
const iterator = s[Symbol.iterator]()

console.log(iterator.next()) // {value:1, done: false}
console.log(iterator.next()) // {value:2, done: false}
console.log(iterator.next()) // {value:3, done: false}
console.log(iterator.next()) // {value:undefined, done: true}
```
> 运行Symbol.iterator方法来获取iterator的迭代器，执行迭代器的next方法来获取下一个对象元素的值

### 25. 实现迭代接口
```
const obj = {
  store: [1,2,3,4],
  [Symbol.iterator]: function() {
    let index = 0
    const self = this
    return {
      next: function() {
        const result = {
          value: self.store[index],
          done: index >= self.store.length
        }
        index++
        return result
      }
    }
  }
}

for(const item of obj) {
  console.log(item)
} 
// 1
// 2
// 3
// 4
```

### 26. 生成器
```
 function * foo() {
   console.log('11111')
   yield 100
   console.log('22222')
   yield 200
   console.log('33333')
   yield 300
 }
const generator = foo()

 console.log(generator.next()) // 11111 {value:100, done: false}
 console.log(generator.next()) // 22222 {value:200, done: false}
 console.log(generator.next()) // 33333 {value:300, done: false}
```
> 执行生成器函数会返回一个生成器，遇到yield关键字函数函数会停止执行，直到生成器对象调用了next方法，才会继续往下执行。
```
const obj = {
  store: [1,2,3,4],
  [Symbol.iterator]: function * () {
    for(const item of this.store) {
      yield item
    }
  }
}

for(const item of obj) {
  console.log(item)
}
// 1
// 2
// 3
// 4
```

### 27. ES2016
```
const arr = ['foo', 1, NAN, false]
arr.indexOf('foo') > -1 === arr.includes('foo') // 数组或字符串的包含方法

Math.pow(2, 10) === 2 ** 10 // 指数运算符
```

### 28. ES2017
```
const obj = {
  foo: 'value1',
  bar: 'value2',
  get full() {
    return this.foo + this.bar
  }
}

Object.values(obj) // ['value1', 'value2'] 获取对象所有的值的数组
Object.entries(obj) // [['foo', 'value1'], ['bar': 'value2']] // 获取对象对应的键值对的数组
Object.getOwnPropertyDescriptors(obj) // 获取对象属性的完整描述 包括get 和 set 方法

const books = {
  html: 5,
  css: 10,
  javascript: 128
}

for(const [key, value] of Object.entries(books)) {
  console.log(`${name.padEnd(16, '-')}|${value.toString().padStart(3, '0')}`)
}
// html------------|005
// css-------------|010
// javascript------|128
```
> padEnd、padStart 如果字符串位数不够，就用指定的字符串从前面或者后面填充至满足指定的位数要求

 ### 29. 异步模式
 > EVENT LOOP 负责监听调用栈和消息队列，当调用栈内的任务都执行完毕了之后，EVENT LOOP 就会将消息队列中的任务压入到调用栈中再执行任务。
 > 计时器、事件监听、Promise、ajax 都是属于异步操作。

 