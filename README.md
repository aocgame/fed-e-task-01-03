# fed-e-task-01-01
fed-e-task-01-01

1. 
> 10
> 用 'var' 声明的变量会上升到全局。循环i自增到10的时候，退出循环。console.log(i) 打印的是全局的i变量，此时的i的值为10，所以打印的结果为10。

2. 
>tmp is not defined

>'let' 关键字声明的变量的作用域是块级作用域，即{}花括号之间的作用域。由于let关键字声明的变量不会上升到全局，所以在let关键字声明变量之前使用该变量，改变量还没有被定义。所以console.log打印出来的变量值就是undefined。

3. 
```
Math.min(...arr)
```

4. 
>var 声明的变量可以在函数作用域或者全局作用域内访问，并且可以跨块访问

>let 声明的变量可以块级作用域中访问，不可以跨块访问

>const 的作用域和let声明的变量作用域一致，只是const一旦赋值后，便不能给变量重新赋值

5. 20
>obj.fn() 函数被谁调用this就会指向调用者，即obj 所以函数fn中this的指向就是obj。setTimeout的回调函数用的是箭头函数，箭头函数的特点是不会改变this的指向，即箭头函数的this取决于它的父级作用域的this的指向，就是fn的this的指向obj，所以this.a就等于obj.a，所以打印出来的结果就是20。

6. 
>从ES6开始Symbol作为一种新的基本数据类型。它可以作为对象属性的唯一标识符。通过Symbol()方法可以返回一个symbol类型的唯一标识符。

>`var b = {}; b[Symbol()] = 'value';` 此时`Object.getOwnPropertyNames(b)`不能获取对象的symbol类型键值的属性，但是可以用`Object.getOwnPropertySymbols(b)`来获取键值为symbol类型的属性名。

用`for in`或者`Object.keys`或者`JSON.strigify`等方法 不能枚举键值为symbol类型的key， 但是可以使用Reflect.ownKeys来枚举键值为symbol类型的对象属性。

7. 
>浅拷贝：如果待对象的属性值是值数据类型则直接赋值，如果待复制的对象的属性的值是引用类型，那么只复制引用类型的地址。如果改变拷贝对象的属性值，那么也可能对被拷贝对象造成影响。

>深拷贝：如果待对象的属性值是值数据类型则直接赋值，如果待复制的对象属性是引用类型则深度遍历所有的被拷贝对象的属性，生成全新的对象赋值给拷贝对象。改变拷贝的对象属性是不会影响到被拷贝对象的。


8. 
>EVENT LOOP 指的是javascript的事件循环，用来监听执行栈和消息队列，当执行栈的任务执行完毕的时候，事件循环会将消息队列中的任务压入到执行栈中依次执行。

>微任务：包括 Promise、process.nextTick 等操作，是在主线程任务执行完毕之后执行的任务，当执行主线程任务的时候遇上了微任务，会先将微任务压入到微任务队列中，等待主线程的任务都执行完毕之后，再在微任务队列中依次执行队列中的微任务。

>宏任务：包括setTimeout、setInterval、setImmediate、I/O、UI 等操作，但主线程的任务和微任务的队列都执行完毕后才执行的任务，当主线程遇上了宏任务的时候先将宏任务压入到宏任务的队列当中，等到主线程和微任务队列中的任务都依次执行完毕之后，才会依次执行宏任务队列中的任务。

9. 
```
Promise.resolve('hello')
.then(res => res + 'lagou')
.then(res => res + 'I ❤ U')
.then(res => console.log(res))

```

10. 
>Typescript是Javascript的超集。Typescript提供了静态类型检查、接口等概念，可以在编译阶段就检查出代码的错误，提高了代码的安全性，使得开发人员在编译阶段就能够快速的定位错误的位置，减少代码运行时的错误。Typescript提供了‘类’的概念，模块的概念。Typescript可以通过编译器编译成Javascript运行。

11. 
>优点：
>Typescript支持静态类型检查，在开发人员在编辑代码的时候就发现错误，使得开发人员更早、更快的发现代码的错误，促使开发人员编写更加健壮的代码，帮助编写的代码更好、更清晰。

>Typescript可以在代码编写时就发现一些问题，这样就降低了代码修改和重构的所带来的风险。

>用Javacript在多人协作编写项目时，有时候靠的是一些约定来保持代码的统一性和正确性，但是光靠约定来维持代码的统一性是不够的，使用Typescript可以在编写代码的时候就对代码进行一些相应的限制，保证多人协作时代码的准确性。例如可以用枚举类型，来限制变量的取值，给枚举类型以外的值进行赋值，代码就会给出相应的错误提示。

>Typescript提供了所有的ECMAScript的新功能，和新数据类型和结构的实现，保证了不同平台使用ECMAScript的兼容性，可以将代码编译成最早ES3的版本。使得开发人员可以使用最新的功能，提高项目的开发效率。等等。

>缺点：
>Typescript的学习曲线相比Javascript更加的陡峭，初学者学习和使用Typescript需要花费相比Javascript更多的事件和精力。

>Typescript需要通过编译器，编译成Javascript才能够执行，否则不能直接运行Typescript程序。

>Typescript的强类型，需要开发人员对代码进行注解，这使得开发效率变慢。

>Typescript的强类型，不支持变量的隐式类型转换，失去了Javascript的灵活性。